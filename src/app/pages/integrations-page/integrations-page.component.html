<section class="text">
  <!-- <ngb-accordion #a="ngbAccordion" activeIds="custom-panel-1">
      <ngb-panel id="custom-panel-1">
        <ng-template ngbPanelHeader let-opened="opened">
          <div class="accordion-button custom-header justify-content-between" [class.collapsed]="!opened">
            <p class="m-0">General Notes - {{ opened ? 'opened' : 'collapsed' }}</p>
            <div>
              <button ngbPanelToggle class="btn btn-sm btn-outline-primary ms-2">General notes</button>
              <button ngbPanelToggle class="btn btn-sm btn-outline-primary ms-2">Toggle second</button>
              <button type="button" class="btn btn-sm btn-outline-secondary ms-2" (click)="disabled = !disabled">
                {{ disabled ? 'En' : 'Dis' }}able third
              </button>
              <button type="button" class="btn btn-sm btn-outline-danger ms-2" (click)="a.collapseAll()">Collapse all</button>
            </div>
          </div>
        </ng-template>
        <ng-template ngbPanelContent>
          <p>Forms can be made using html and data binding (template-driven form) or defining the form model and validation in
      the component code (reactive form).</p>
        </ng-template>
      </ngb-panel>
      <ngb-panel>
        <ng-template ngbPanelHeader let-opened="opened">
          <div class="accordion-button custom-header justify-content-between" [class.collapsed]="!opened">
            <p class="m-0">Second panel</p>

          </div>
        </ng-template>
        <ng-template ngbPanelContent>
          Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia
          aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor,
          sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica,
          craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings
          occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus
          labore sustainable VHS.
        </ng-template>
      </ngb-panel>
      <ngb-panel [disabled]="disabled" [cardClass]="disabled ? 'disabled' : ''">
        <ng-template ngbPanelHeader let-opened="opened">
          <div class="accordion-button custom-header" [class.collapsed]="!opened">
            <button ngbPanelToggle class="p-0 btn btn-link container-fluid text-start ps-0">Third panel</button>
            <p *ngIf="disabled" class="text-muted m-0 small">[I'm&nbsp;disabled]</p>
          </div>
        </ng-template>
        <ng-template ngbPanelContent>
          Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia
          aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor,
          sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica,
          craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings
          occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus
          labore sustainable VHS.
        </ng-template>
      </ngb-panel>
      <ngb-panel>
        <ng-template ngbPanelHeader>
          <button ngbPanelToggle class="accordion-button">Default-looking "custom" panel</button>
        </ng-template>
        <ng-template ngbPanelContent>
          Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia
          aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor,
          sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica,
          craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings
          occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus
          labore sustainable VHS.
        </ng-template>
      </ngb-panel>
    </ngb-accordion> -->

  <h2>General notes</h2>
  <p><b>Remember the goal is to understand what the heck I'm doing, and also be able to use this as a point of reference
      (like my notes) webpage when working.</b><br>
    The API connection is the key thing I need to get from here, but making html and ts files talk to eachother in the
    exercises ups my overall knowledge of integrations.</p>
    <p>When writing an interface a question mark is used to describe a parameter that may or may not exist in the actual data. e.g <code class="codeC2"> activeStatus?: string, </code></p>
    <hr>
  <p>Forms can be made using html and data binding (template-driven form) or defining the form model and validation in
    the component code (reactive form). <br>
    Angular is able to watch for changes in the state of a reactive form. Untouched, it's called "pristine", touched
    it's "dirty".<br>
    <img src="/assets/Images/page-states.png" alt=""></p>
  <p>Reactive forms are better suited for complex scenarios.</p> <br>
  <div>
    <p><b>Steps to building a reactive form</b><br>
      To build a reactive form first</p>
    <ol>
      <li> Import form control and form groups from angular forms. </li>
    </ol>

  </div>

  <h2>Rename Glossary</h2>
  <ul>
    <li>Form controls = stuff like input elements</li>
    <li>Form group = form itself</li>
    <li>Form model = html structure of form</li>
    <li>Directive = component of a dependency import</li>
    <li>Root FormGroup = main FormGroup holding other FormGroups</li>
    <li>key = var from the ts file holding the value inputed in the checkbox </li>
    <li>value = value of the key as inputed in the textbox</li>
    <li>FormArray = a group of formControls and/or FormGroups. They're accessed by index instead of name.</li>
  </ul>

  <p><b>Binding to HTML</b><br>
    --formControlName is used to bind each input element to its associated formControl.<br>
    --formControlName is added to every directive we want to track in the input element of the form. The string names
    them.<br>
    --Sometimes we need to have the HTML access the data/properties of the form in order to take actions like display
    its style. Here's a pic of how that's done. <br>
    <img src="/assets/Images/Accessing-form-properties.png" alt="">
  </p>
  <p>setValue and patchValue are used to update info on the form from the component file.<br>
    setValue is used to set the value of every formControl in the module and won't work except you have a value for
    every formControl. <br>
    setValue is used to set the values of all the formControls while patchValue is used to set just specified ones.
  </p>

  <p><b>Form Builder</b>
    Is used to generate formGroups and formControls for you.<br>
    It shortens the boilerplate code for the form.<br>
    It's provided as a service so uses dependency injection.</p>

  <p><b>Binding html to ts</b></p><img src="/assets/Images/Binding-ts-to-html.png" alt="">

  <h4>Cross-Field Validation</h4>
  <p>The trick to cross field validation is to make a nested form group within the larger form which would then be
    validated together.</p> <br>
  <img src="/assets/Images/Cross-field-validation-nested-FB.png" alt="">
  <br>&nbsp;<br>

  <h2>Reference links</h2>
  <p>
    Overall, I've seen that to actually do these, I'll need to reference the tutorial again to follow it step by step
    until I get so used to it I never have to reference the tutorial again.<br>
    It is advisable to watch the intro and the checklist (outro) first before actually going in to revisit videos in a
    module you're revisiting.
  </p>
  <ul>
    <li><a class="link"
        href="https://app.pluralsight.com/course-player?clipId=efc2e9cf-30ea-440c-bef7-14e40af503c7">Reacting by
        changing validation rules </a></li>
    <li><a class="link"
        href="https://app.pluralsight.com/course-player?clipId=e1cdcfcb-352d-4a9e-ba3b-5bbbc9f5ebbc">Using
        debounceTime</a></li>
    <li><a class="link" href="https://app.pluralsight.com/course-player?clipId=653319b8-da9b-467e-8036-d7350c0d18d2">The
        checklist of module 7 shows the features of the form that were taught.</a> If ever lost, check the intro or the
      checklist for what happened in that module.</li>
    <li><a class="link"
        href="https://app.pluralsight.com/course-player?clipId=018f7fa9-5412-4e98-96bf-22d6ce970335">Getting product ID
        to display corresponding UI.</a></li>
    <li><a class="link"
        href="https://app.pluralsight.com/course-player?clipId=ff42b4cc-01de-4b15-aaae-314f2c833d13">Faking a backend
        server</a></li>
    <li><a class="link"
        href="https://app.pluralsight.com/course-player?clipId=5fb25354-6e62-42e3-8308-5ecc5c3d23a6">Module 9
        particularly shows how to fake backend, get, post, to it etc which is the same process with a real server. Take
        out the fake to use the real then it's all the same.</a> </li>
    <li><a class="link"
        href="https://dev.to/ferfox1981/tree-ways-to-scroll-to-an-element-using-angular-1dlj">Scrolling to a div on same page</a></li>
    <li> <a class="link"
        href="https://stackoverflow.com/questions/61213888/how-to-programmatically-click-on-a-button-maybe-angular">Clicking a button via code</a> &nbsp; <a href="https://stackblitz.com/edit/angular-viewchild-example-23mt1g?file=app%2Fapp.component.ts%3AL11">Stackblitz</a> </li>
        <li> <a class="link"
          href="https://app.pluralsight.com/course-player?clipId=21345ca1-0268-4db0-b92f-5b7720bdafd9">Pipe creation</a> </li>
          <li> <a class="link"
            href="https://app.pluralsight.com/course-player?clipId=12e97abe-1601-4488-ac72-2744a8042183">String filter</a>  </li>
        </ul>
<br>
<br>

  <p>debounceTime - ignores all events until a specific amount of time has passed without another event. <br>
    debounceTime(1000) waits 1 second before another event. <br></p>

  <p>It's important to know how to watch something for changes by subcribing to the necessary observable </p>
  <img src="/assets/Images/watching-with-observable.png" alt="">

  <p>After watching, you should be able to react to it. The highlighted function is called when the value change is
    noticed by the observable. Below is the syntax to react to a change with setNotification(value) being a function you
    predefined already.</p>
  <img src="/assets/Images/reacting-to-change.png" alt="">

  <p>debounceTime is often used in forms and here's the syntax with the part of the code that actually adds the
    debounceTime highlighted. <span style="color: rgb(218, 218, 31);">.pipe(debounceTime(1000))</span></p>

  <p>Here are the stepds to duplicating a formGroup instance</p>
  <img src="/assets/Images/steps-to-duplicate-elements.png" alt="">
  <br>

  <h4>Getting ID from Route</h4>
  <p>You can get the id of an item to make the page display the UI linked to that ID by using a snapshot or an
    observable. Use an observable if you expect the parameter to change while you're still on the page. The below image
    shows snapshot first then observable method below it.</p>
  <img src="/assets/Images/get id via route.png" alt="">
  <br>
  <h2>CRUD Operations: Integrating to Backend</h2>
  <ol>
    <li>Create a data-access-service <i>(to separate concerns and for reusability)</i></li>
    <li>Set up the backend server</li>
  </ol>

  <h6 id="service">Creating a Data Access Service</h6>
  <img src="/assets/Images/steps to building data access service.png" alt="">

  <h6 id="backend">Setting up the Backend Server</h6>
  <img src="/assets/Images/setting up backend server.png" alt="">

  <br>&nbsp;<br>
  <h4>CRUD Service File Syntax</h4>
  <div class="frame">
    <code>
      <p>import {{ '{' }} HttpClient, HttpHeaders } from '@angular/common/http'; <br>
        import {{ '{' }} Observable, of, throwError } from 'rxjs'; <br>
        import {{ '{' }} catchError, tap, map } from 'rxjs/operators'; <br>
        <br>&nbsp;<br>
        @Injectable ({{ '{' }} <br>
        &nbsp;&nbsp; providedIn: 'root' <br>
        }) <br>
        <br>&nbsp;<br>
        export class ProductService {{ '{' }} <br>
        &nbsp;&nbsp; private baseUrl = 'www.myWebService.com/api/products'; <br>
        <br>
        &nbsp;&nbsp; constructor(private http: HttpClient) {{ '{' }}} <br>
        <br>
        &nbsp;&nbsp; getProduct(id:number): Observable&lt;Product&gt; {{ '{' }} <br>
        &nbsp;&nbsp; &nbsp;&nbsp;const url = `${{ '{' }}this.baseUrl}/${{ '{' }}id}`; <br>
        &nbsp;&nbsp; &nbsp;&nbsp;return this.http.get&lt;Product&gt;(url); <br>
        }
        }
      </p>
    </code>
  </div>
  <p>Create using <code class="codeC2">http.post</code>, read using <code class="codeC2">http.get</code>, update using
    <code class="codeC2">http.put</code>, and delete using <code class="codeC2">http.delete</code>. </p> <br>

  <h1>Faking a Backend</h1>
  <img src="/assets/Images/faking a backend.png" alt="">
  <p>Hard coding doesn't make use of http services so it won't do. Using the Json method, you can get the data but can't
    post to it. Hence the in-memory-web-api is a better choice.</p> <br>
  <p><b>Using and In-Memory-Web-API</b></p>
  <ol>
    <li>Install the in-memory web api: <code class="codeC2">npm install angular-in-memory-web-api --save-dev</code></li>
    <li>Create your backend data file(class) <ul>
        <li>Import <code class="codeC2">InMemoryDbService</code> from 'angular-in-memory-web-api' so the class can
          implement InMemoryDbService, also to gain access the <code class="codeC2">createDb</code> method.</li>
        <li>Create an interface file to define the data types for strong typing and import it here too</li>
        <li>Use the createDb method to create the object holding the array of data.<br>
          <div class="frame"> <code> createDb(): {{ '{' }} data: Data[] }{{ '{' }} <br>
              &nbsp;&nbsp;const data: Data[] = [ InsertArrayHere ]; <br>
              &nbsp;&nbsp;return {{ '{' }} data }; <br>
              } </code> </div>
        </li>
      </ul>
    </li>
    <li>Import <code class="codeC2">HttpClientInMemoryWebApiModule</code> to the imports section of relevant module of
      the page that needs to call from that back (or app.module).</li>
    <li>Import your backend data file(class) which you just made to the same module</li>
    <li>Add to the imports section of the module, <code
        class="codeC2">InMemoryWebApiModule.forRoot(dataFileClass)</code></li>
    <li>Create a service for your CRUD. <br>
      Inject the service in the constructor of the .ts file of the relevant page that needs the service.</li>
    <li>Write code to read the http path (in the service). <br>
      It usually starts with 'api' then the name of the object holding the data array. E.g "api/data"</li>
    <li>Inject http of type HttpClient to the constructor like so: <code class="codeC2">constructor (private http:
        HttpClient)</code></li>
    <li>Write the get method (subscribing to the observable in it) and test that it works.</li>
  </ol>



  <h1>CRUD Operations</h1>
  <ol>
    <li>Import HttpClientModule in imports array of module</li>
    <li>Build data-access-service (passing HttpClient in the constructor and importing necessary things)</li>
    <li>Create a method for each http request (pass in url to desired server in methods, & any arguments)</li>
    <li>Add error handling</li>
    <li>To use your data-access-service in any page, inject it into that page's constructor</li>
    <li>For each of the data-access-service's methods called up, sub to the observable</li>
    <li>Provide a function to run when the observable brings an item. Add an error function to handle any errors.</li>
    <li>Repeat 1-7 whenever you need to perform a data service operation from your data-access-service.</li>
  </ol>
  <p>Create using post, read using get update using put and delete using delete. </p>

  <div class="CrudNotes">
    <h3>Notes From Using CRUD Practically.</h3>
    <p>Here's the syntax to route to a specific code ID: <br></p>
    <div class="frame">
      <code>[routerLink]="['/products', product.id, 'edit']"</code>
    </div>
    <p>Essentially, function A happens, then B is called, who then returns an observable and as function C is alerted by
      the observable, he runs and his result calls function D etc. That's pretty much the flow of getting, posting and
      working with HTTP requests as I've noticed it. That's how the logic flows, so perhaps write the functions in order
      of how they'll happen. </p>
    <p><b>--Void in functions</b>: When a function doesn't state to return <code>'void</code> or <code>'any</code>, you
      have to state <code>returns yourCodeHere</code> for things to work. It your function returns void, you can go
      straight into coding.</p>
    <p><b>--Displaying data for View vs for Edit</b>: To show data to a page you pass the res to an object then bind
      using object.parameter in the html, but to display it in a form, you pass the res into a display items function
      (<i>which is inside a getItemForEditingById function</i>). This getItemForEditingById function is called in
      ngOnInit in the function for reading the route id from the top bar.</p>
    <p>When trying to interact with a html element by code (using @viewChild), if nativeElement is not working, try putting it in ngAfterViewInit and that should make it work.</p>
  </div>
  <br>

  <p><B>Signing Into Swagger</B>:</p>
  <ol>
    <li>Go to user auth --> click the login endpoint --> click "try it out" --> replace 'string' with username then password --> put client's ID and
      Key (from environments.ts). --> click execute</li>
    <li>It returns a token at the end of the response --> copy token --> scroll to top and click 'authorize' --> in
      vlaue field type 'bearer pasteTokenNumber' --> click authorize. </li>
  </ol>

<br>

  <!-- ----------------  Reading Route Parameter  ------------------------- -->

  <div>
    <h4 id="readRoute">Reading a route parameter</h4>
    <a href="https://app.pluralsight.com/course-player?clipId=018f7fa9-5412-4e98-96bf-22d6ce970335">(Reference1)</a>
    &nbsp; <a
      href="https://app.pluralsight.com/course-player?clipId=018f7fa9-5412-4e98-96bf-22d6ce970335">(reference2)</a>
    the way your functions know the id of the product for it to bring the specific details of that product is by
    reading the id in the route. To do that,
    <ul>
      <li>First <b>bind the id to the route path</b> so that that id shows in the top bar when you're on the destination page (edit page).
        You can only bind it when you've ran the get method and passed the response into the objecy 'item'. Then you can
        bind it like so: <p> <b class="codeC2">[routerLink]="['/pages/testing', item.id , 'edit-page']"</b> in the html
          button, and <code class="codeC2">{{ '{' }} path: 'pages/testing/:id/edit-page', component: EditPageComponent
            {{ '}' }}</code> in the routing component. </p>
      </li>
      <li>in the destination (edit) page's ts: import ActivatedRoute, inject it in the constructor, </li>
      <li>utilizing ActivatedRoute to get the id, use snapshot or use an observable following this code (<i>this is
          where you define const id</i>):<br> <img class="img" src="/assets/Images/reading routes to get id.png"> the id
        in the fn is read straight from the route </li>
      <li>set up the reading of the route parameter in ngOninit.</li>
    </ul>
  </div>
  <br>
  <h1><u>Doing CRUD</u></h1>
  <p>These are notes on the basic steps taken in each of the crud operations.</p>

    <!-- --------------------------GET CRUD------------------------------------ -->

  <h3 id="get">GET</h3>
  <p><b>The Get Method</b>: Use this method to get data of any sort from the backend</p>

  <br>
  <p><b>Getting Data to UI</b>: When trying to get data from Swagger to the UI (especially if it's a list), these are the steps (pay attention to what's in bold):</p>
  <ol>
    <li><b>Create an interface</b> for the data expected to come in from Swagger (backened) to perfectly match the data types
      expected for each thing. A parent interface and a child interface (which would be used as a data type in the
      parent). <br>
      Between the use of parent and child interfaces all the objects in the response body should be properly accounted
      for in the interfaces. </li>
    <li><b>I wrote a function in the service.ts</b> to get the data from Swagger, of an observable interface type (<i>remember
        the [] should be ommitted so that child interfaces can be accessed</i>), passing in the userId which it's to get
      the data by. It returns a get method that uses the link to the Swagger data (or relevant backend) and passing in
      the userId to get it by. </li>
    <li><b>I then wrote in the ts file</b>, a get method calling the function from the service, passing in the userId and
      .subscribe to it.</li>
    <li>In the response after the .subscribe, <b>I passed the response into an object "jobs"</b> (which would have to be
      defined with it's correct type in the definitions section, prolly an interface). </li>
    <li><b>In ngOnInit call </b> <code class="codeC2">this.yourGetMethod(userId)</code>. So that the get method would run
      automatically when the page is loaded and you can actually have access to the data. </li>
    <li><b>In the HTML, bind the object</b> "jobs" (which you passed the response into), then you can use .whatever from the
      interface child or JavaScript method and it'll show. You can also use <code class="codeC2">"ngFor item of jobs"</code></li>
  </ol>
  <p>Below is a code snippet you can copy, paste and change the text to the relevant names of your own code.</p>  <br>

  <div class="frame">
    <code>
      <span class="comment">//this is the get function in the service.ts file</span> <br>
      getData(){{'{'}}   <br>
        return this.http.get&lt;IInterface&gt;(`${{'{'}}this.baseUrl{{'}'}}/link/link`);   <br>
      {{'}'}} <br>

      <span class="comment">//in the ts file</span> <br>
      ngOnInit(): void {{'{'}} <br>
      &nbsp;&nbsp;&nbsp;&nbsp; this.getItems(); <br>
      &nbsp;&nbsp; {{'}'}} <br>
      <br>

      <span class="comment">//this function would be called in ngOninit</span> <br>
      &nbsp;getItems(){{'{'}}   <br>
      &nbsp;&nbsp;  this.service.getData()<span style="color: cornflowerblue;">.subscribe(   <br>
      &nbsp;&nbsp;&nbsp;&nbsp;    {{'{'}} next: (res) => {{'{'}} this.fullData = res;   <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.fullData); {{'}'}},   <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error: (error) => {{'{'}} console.log(error); {{'}'}} <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{'}'}}   <br>
      &nbsp;&nbsp;    )</span>;   <br>
      &nbsp;{{'}'}} <br> <br>

    </code>
  </div>

      <!-- --------------------------VIEW CRUD------------------------------------ -->

      <h3 id="view">VIEW</h3>
      <p>Use the routing to let the code know which item you're viewing by binding the id to the route as shown in the
        <button (click)="goToreadRoute()">reading a route parameter</button> section above.<br>
        Go to the ts file of the view page then:</p>
      <ol>
        <li> Import Subscription from rxjs, make a private sub: Subscription in the definitions section. </li>
        <li> Import and inject ActivatedRoute(in constructor).</li>
        <li> Create an <b>object: IData</b> to hold your res. </li>
        <li> Write your getById method calling the getById of the service.ts, subscribing and passing the res into the
          <b>object</b>. </li>
        <li> In ngOnInit, write code to read the route parameter and in the same fn run your getById method, passing in the
          id you just read. </li>
        <li> Data bind it in the html using <code class="codeC2">{{'{'}}{{'{'}}object.parameter{{'}'}}{{'}'}}</code> </li>
      </ol>
      <p>Here's the code example for numbers 4 and 5 (5 first). &nbsp;&nbsp; <i>Both show different ways (syntaxes) to write
          the response after a subscribe.</i></p>
      <div class="frame">
        <code>
          ngOnInit(): void {{'{'}} <br>
          <!-- //reading the id of an item from the id in the path at the top bar of the page      <br> -->
          &nbsp; this.sub = this.route.paramMap.subscribe( <br>
          &nbsp;&nbsp; params => {{'{'}} <br>
          <!-- //this pulls the id from the parameters array and puts into the const which is then put into the getItemForViewingById method. <br> -->
          &nbsp;&nbsp;&nbsp;&nbsp; const id = +params.get('id')!; <br>
          &nbsp;&nbsp;&nbsp;&nbsp; this.getItemForViewingById(id); <br>
          &nbsp;&nbsp; {{'}'}} <br>
          &nbsp; ) <br>
          {{'}'}} <br>
          <br>
          getItemForViewingById(id: number): void {{'{'}} <br>
          &nbsp; this.service.getDataById(id) <br>
          &nbsp;&nbsp; .subscribe({{'{'}} <br>
          &nbsp;&nbsp;
          <!-- // next: (res: IData) => console.log(res),      <br> -->
          &nbsp;&nbsp; next: res => this.item = res, <br>
          &nbsp; {{'}'}}); <br>
          {{'}'}} <br>
        </code>
      </div>
      <br>





  <!-- --------------------------CREATE CRUD------------------------------------ -->

  <H3 id="post">CREATE (POST)</H3>
  <ol>
    <li>Write http.post function in service.</li>
    <li>Call it up in a local create fn. In this fn, you put the form group into a const 'I' -> next line, pass 'I' into
      <code class="codeC2">this.service.createItem</code> fn</li>
  </ol>
  <p>Here are the functions in the service and then the local create (save) fn in the ts respectively</p>
  <div class="frame">
    <code>
       createItem(savedItem: IData) {{'{'}} <br>
      &nbsp;&nbsp; const headers = new HttpHeaders ({{'{'}}'Content-Type' : 'application/json'{{'}'}}); <span class="comment">//specifies that the content will be in json format</span> <br>
      &nbsp;&nbsp; return this.http.post&lt;IData&gt;(this.baseUrl, savedItem, {{'{'}} headers {{'}'}}) <br>
       {{'}'}} <br>
    </code>
    <br>
    <code>
      saveFn(){{'{'}}               <br>
     &nbsp;   const I = {{'{'}}...this.item, ...this.listDataForm.value{{'}'}} <span class="comment">//copies listDataForm's value over item and puts the result inside I</span>               <br>
     &nbsp;   this.service.createItem(I)               <br>
     &nbsp;&nbsp;     .subscribe({{'{'}}               <br>
     &nbsp;&nbsp; &nbsp;      next: () => this.onSaveComplete()               <br>
     &nbsp;&nbsp;      {{'}'}}) <br>
           {{'}'}}               <br>
      onSaveComplete(): void {{'{'}}               <br>
     &nbsp;  this.router.navigate(["/pages/testing"]);               <br>
      {{'}'}}               <br>
    </code>
  </div>
  <br>


  <!-- --------------------------EDIT CRUD------------------------------------ -->

  <h3 id="edit">EDIT (PUT)</h3>
 Basic steps: ** capture the id,  (so it shows in address)
** route using it,
** getById (service),
** getById(ts),
** displayFn,
** call getById ts version, passing in his res
  <p><b>Retrieving Specific Item To Form</b>: When trying to populate a form with existing data, say for editing, these
    are the steps:</p>
  <ol>
    <li>Write code to read the id of the specific data to be retrieved from the route as shown in <button
        (click)="goToreadRoute()">reading a route parameter</button> above (so it can actually get the correct item).
    </li>
    <li>Write your getById function in the service file (passing in the id).</li>
    <li>Write another getById2 function in the ts file (passing in the id), which'll call the service file's fn in it
      like so: <code class="codeC2">this.service.getById</code></li>
    <li>Write a displayItems fn, where you'll use <code class="codeC2"> this.formGroup'sName.patchValue({{'{'}}
        formControlName: this.item.parameter, {{'}'}})</code> to put the current relevant parameters in each of their
      corresponding form controls.</li>
    <li>In the edit-page's ts file's ngOnInit, in your fn to read the route's id, put this.getById2 passing in the id.
      getById2 MUST pass in his res to displayItems function </li>
  </ol>
  <p>So there are 3 major functions that work together here. <span class="red">fn to read the route's id(in
      ngOnInit)</span>, who calls
    <span class="blue">getItemForEditingById</span>, who calls <span class="green">displayItems</span> passing in his
    res. Here are the functions respectively: </p>
  <div class="frame">
    <code>
      ngOnInit(): void {{'{'}} <br>
      &nbsp; this.sub = this.route.paramMap.subscribe( <br>
      &nbsp;&nbsp; params => {{'{'}} <br>
      &nbsp;&nbsp;&nbsp; const id = +params.get('id')!; <br>
      &nbsp;&nbsp;&nbsp; this.getItemForEditingById(id); <br>
      &nbsp;&nbsp; {{'}'}} <br>
      &nbsp; ) <br>
      {{'}'}}
    </code>
    <br>
    <code class="blue">
      getItemForEditingById(id: number): void {{'{'}} <br>
      &nbsp; this.service.getDataById(id) <br>
      &nbsp;&nbsp; .subscribe({{'{'}} <br>
      &nbsp;&nbsp;&nbsp; next: (res: IData) => this.displayItems(res) <br>
      &nbsp; {{'}'}}); <br>
      {{'}'}} <br>
    </code>
    <br>
    <code class="green">
      displayItems(itemsForDisplay: IData) {{'{'}} <br>
      &nbsp; this.item = itemsForDisplay; <br>
      &nbsp; this.listDataForm.patchValue({{'{'}} <br>
      &nbsp; &nbsp; number: this.item.serialNo, <br>
      &nbsp; &nbsp; parameter: this.item.parameter, <br>
      &nbsp; &nbsp; type: this.item.type, <br>
      &nbsp; &nbsp; description: this.item.description, <br>
      &nbsp; {{'}'}}); <br>
      {{'}'}} <br>
    </code>
  </div>
  <br>

    <!-- --------------------------POST CRUD------------------------------------ -->

    <h3 id="uhn">SAVING (PUT)</h3>
    <p>To edit, you need to actually save changes. Done by using JS spread properties which lets us copy data from an
      existing object to a new object, edit that and push it. like so: <img class="img"
        src="/assets/Images/saving edits.png" alt=""></p>
    <p>The update function essentially takes in the item you juse edited, and in the http.put, it says "here's the url, to
      put this item, as a json. Like so:</p>
    <img class="img" src="/assets/Images/http put.png" alt="">
    <ol>
      <li>Write the updateItem function in the service. Use the format in tht image above.</li>
      <li>Write a local saveEditsFn method that calls <code class="codeC2">this.service.updateItem(P)</code>, passing in
        the const P where your edits have been pasted over the old edits. --> Subscribe to the observable returned by the
        update method --> use <code class="codeC2">next: () => this.onSaveComplete.()</code>. onSaveComplete can just
        route to wherever (<i>or this.form.reset() first</i>).</li>
    </ol>
    <p>Here's the edit method, just reworded a bit:</p>
    <div class="frame">
      <code>
        &nbsp;saveEditsFn(): void{{'{'}} <br>
        &nbsp;&nbsp; const I = {{'{'}}...this.item, ...this.listDataForm.value{{'}'}} <span class="comment">//copies listDataForm's value over item and puts the result inside I</span>
        <br>
        &nbsp;&nbsp; this.service.updateItem(I) <br>
        &nbsp;&nbsp;&nbsp; .subscribe({{'{'}} <br>
        &nbsp;&nbsp;&nbsp; next: () => this.onSaveComplete() <br>
        &nbsp;&nbsp; {{'}'}}) <br>
        {{'}'}} <br>
      </code>
    </div>
    <br>

  <!-- --------------------------DELETE CRUD------------------------------------ -->

  <h3 id="delete">DELETE</h3>
  <p>In most delete cases the item isn't truly deleted. A http.put is just used to set its status as deleted so that
    what's showing on the UI are only those with status of "not-deleted", or those that don't include the delete status
    depending on how you want to write it. </p>
  <p>But if you must delete, here is the code to do actual delete:</p>
  <ol>
    <li>Write the delete method in the service file. <i>(note: similar to put and post but returns an observable of
        nothing &lt;{{'{'}}{{'}'}}&gt;, takes in just baseUrl/id, and passes no item into it )</i> <br> <img class="img"
        src="/assets/Images/http delete.png" alt=""> </li>
    <li>Call it up with a local delete function. <br> <img class="img" src="/assets/Images/call delete method.png"
        alt=""> </li>
        <h3><b>Deleting using a confirmation modal.</b></h3>
        <p>Sometimes you may need to use a modal to confirm whether to delete an item or not before deleting. If that's the kind of delete you want to do, <a [routerLink]="['/pages/routing-page']" fragment="deleteById" class="codeC2">clickHere</a>, test the delete button you see there to be sure it's the kind of delete you want to do, then read the notes and check the code of this app to see how it's done.</p>
  </ol>
  <br>

  <h1><b>Syntaxes</b>:</h1>
  <h3>Subscription:</h3>
  <p>Use ctrl + F to do a search for the word "subscribe" and in the code frames where it appears, you'll see different syntaxes used to handle subscription.</p>
  <div class="frame">
    <code>
      <span class="comment">//1</span> <br>
      &nbsp;saveEditsFn(): void{{'{'}} <br>
      &nbsp;&nbsp; const I = {{'{'}}...this.item, ...this.listDataForm.value{{'}'}}
      <br>
      &nbsp;&nbsp; this.service.updateItem(I) <br>
      &nbsp;&nbsp;&nbsp; <span style="color: cornflowerblue;">.subscribe({{'{'}} <br>
      &nbsp;&nbsp;&nbsp; next: () => this.onSaveComplete() <br>
      &nbsp;&nbsp; {{'}'}})</span> <br>
      {{'}'}} <br> <br>

      <span class="comment">//2</span> <br>
      &nbsp;getItems(){{'{'}}   <br>
      &nbsp;&nbsp;  this.service.getData()<span style="color: cornflowerblue;">.subscribe(   <br>
      &nbsp;&nbsp;    {{'{'}} next: res => {{'{'}} this.fullData = res; console.log(this.fullData{{'}'}}{{'}'}}   <br>
      &nbsp;&nbsp;    )</span>;   <br>
      &nbsp;{{'}'}} <br> <br>

      <span class="comment">//3</span> <br>
      &nbsp;deleteItem() {{'{'}}    <br>
      &nbsp;&nbsp;  this.service.deleteItemById(this.itemId)<span style="color: cornflowerblue;">.subscribe(    <br>
      &nbsp;&nbsp;&nbsp;     (response) => {{'{'}} this.getItems(); {{'}'}},    <br>
      &nbsp;&nbsp;  )</span>;    <br>
      &nbsp;{{'}'}}    <br>
    </code>
  </div>
  <br>
  <h3>Arrow Function</h3>
  <img src="/assets/Images/arrow fn.png" class="img" alt="arrow function image"> <br>
  <img src="/assets/Images/arrow fn different syntaxes.png" class="img" alt="arrow function multiple lines"> <br>
  <h3>Getter and Setter</h3>
  <img src="/assets/Images/getter and setter.png" class="img" alt="getter and setter">
  <p>The functions run whenever the "_listFilter" is gotten or set. More in the filters page.</p>

  <br><br>
  <h3>Star Component Notes</h3>
  <div>
    <h5>Steps</h5>
    <ul>
      <li>Make your star UI.</li>
      <li>Bind its title to a "rating" object and its width to a "cropwith" object in the ts file.</li>
      <li>Import it to the declarations of the module that'll be using it.</li>
      <li>Use it as a custom html directive. E.g <code class="codeC2">&lt;app-stars&gt;&lt;/app-stars&gt;</code></li>
      <li>Whatever parts of the star component.ts you want to be properties of the custom html, add the <code class="codeC2">@Input()</code>  decorator behing the definition of that property, like a prefix.</li>
      <li>In the html file where the stars are being called as a directive, use property binding to bind the properties of the custom html to their corresponding fields coming from the back end. E.g, <code class="codeC2">&lt;app-stars [rating]="item.rating"&gt;&lt;/app-stars&gt;</code></li>
    </ul>
  </div>

  <br>
  <p><b>Refresh</b>:</p>

  <h1>Importance of UIUX</h1>
  <div>Monument to The Sure Failure of The Development Process Without UIUX.
    Due to making backend without UIUX, a project is prone to have the following issues:
    <ol>
      <li>endpoint is missing entirely, or </li>
      <li>exists but is not working, or </li>
      <li>was working but suddenly stopped working, or </li>
      <li>is missing a parameter, or </li>
      <li>the link was poorly made, or </li>
      <li>the shape of the data is different from what we need, or </li>
      <li>there was a typo relevant enough to hinder integration</li>
    </ol>
    Most of these errors/mistakes would have been caught if a backend was written end to end following a UIUX design. If the endpoints are available, working and have all the parameters the UI needs (as written based on the UIUX), connecting them should go smoother. <br>
    <b>Frontend</b>: <br>
    1. UIUX also guides the frontend in what to make, color codes to use and positioning, and dimensions to use, making it easier to code the UI. <br>
    2. It takes away a lot of revisiting (<i>a step forward today and a step back tomorrow, running in circles</i>) by finalizing product designs with process team, so frontend guys just code out the finished product instead of coding and trying to complete the actual product with the process team simultaneously.
    <b>Extra:</b> <br> With a UIUX product design, you can hire 10 different freelancers/staff, at different times, to work on different parts of the design on both frontend and backend (<i>especially frontend</i>) and still end up with a finished and consistent final product.
  </div> <br>

  <h1>Notes to Remember</h1>
  <p><b>Property Binding</b>: Things like routerlink, class, style, src etc can be used with square braces [] to use
    data binding on their values. E.g, <code class="codeC2">[src]= product.imgUrl.</code> <br>
    That must be the same concept with things like *ngIf and [(ngModel)], where something that says more about a html
    tag is altered using square braces [] or a star * or square braces and a bracket [()]. </p>
  <p><b>Routing With Property Binding</b>: Normally, routing is done going forward from one path to the other with the
    previous path appended at the beginning of the new path. With property binding, you can make it route from one path
    directly to an entirely different path, which is not a child of the current view.<br>
    To ropute to a different location, use property binding like so:
    <code class="codeC2"> [routerLink]="<code>['route/route']</code>"</code>
    where the red text is the bound content of the quotation of the
    routerLink.</p>
  <p><b>Event Binding</b> : () being used is for event binding. E.g (click), (change), etc. That makes the code listen
    for the event in the parenthesis. </p>
  <p>Both property and event binding can be used on the same input element that's why sometimes we see something like
    <span class="codeC2"> [(ngModel)] = 'listFilter ' </span>. To remember the syntax, remember banana in a box [()].
    The property binding is used send imput from the html to the ts. </p>
  <p>When working with an interface, the [] means be restricted to that particular interface but it doesn't drill down
    to the child interfaces. That bracket makes it specific, limited to the parent interface. <br>
  The [] also means that what's expected from the back end is an array, so if you're expecting an array from the back end and they type is not expectedObject[], it may throw an error. <br>
  If you get an error saying <span class="codeC2">Type 'X' is missing the following properties from type 'X[]': length, pop, push, concat, and 26 more.</span> then ensure in your interface.ts, you put the [ ] at the data type of what's expected to be an array. Also ensure it's put as the data type of the object in the component.ts.</p> <br>
  <p>Use pipes whenever you need to make app-specific data transformations which would be re-used often.</p>


    <!-- ---------------------------- TEXT BOX --------------------------------- -->
    <button class="downBtn" (click)="showOrHide()">{{showDiv ? "Hide" : "Note"}}</button>

    <div *ngIf="showDiv" class="notes" [formGroup]="noteArea" >
      <textarea class="form-control" formControlName="note" name="" id="" cols="30" rows="10" placeholder="write temporary text here"></textarea>
    </div>

















<!-- ------------------------------THIS IS THE END---------------------------------- -->
  <br>
  <div class="frame"> THIS IS THE END</div>
  <div (click)="backToTop()" class="backToTopBtn">^</div>
</section>


